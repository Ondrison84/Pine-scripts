//@version=6
//
// Michychy accumulation/breakout strategy
//
// This script implements the described entry and exit logic for long and short
// trades using Pine Script v6.  Version 6 is the current recommended
// Pine Script version, replacing the now‑deprecated v5.
//
strategy("Michychy Accumulation Break Strategy", overlay=true, margin_long=100, margin_short=100, default_qty_type=strategy.percent_of_equity, default_qty_value=10)

// === Inputs ===
// We specify only named arguments when defining inputs to avoid the
// "More than one 'defval' arguments are supplied" error.  In v6,
// providing both a positional value and `defval` duplicates the default.
kcLength    = input.int(defval=20,  title="Keltner Channel Length", minval=1)
kcMult      = input.float(defval=3.0, title="Keltner Multiplier", minval=0.1, step=0.1)
volFactor   = input.float(defval=1.5, title="Volume Factor", minval=0.1, step=0.1)
rangeFactor = input.float(defval=2.0, title="Range Factor",  minval=0.1, step=0.1)

// === Keltner Channels ===
// Version 6 of Pine Script no longer exposes the `ta.keltner()` helper.
// We therefore compute Keltner channels manually using an EMA for the
// middle line and ATR for channel width:
//   Middle = EMA(close, kcLength)
//   ATR    = ta.atr(kcLength)
//   Upper  = Middle + kcMult * ATR
//   Lower  = Middle - kcMult * ATR
midKC   = ta.ema(close, kcLength)
atrKC   = ta.atr(kcLength)
upperKC = midKC + kcMult * atrKC
lowerKC = midKC - kcMult * atrKC

// === Helper calculations ===
bullCandle      = close > open
bearCandle      = close < open
currentRange    = high - low
prevRange       = high[1] - low[1]
rangeCondLong   = currentRange >= rangeFactor * prevRange
rangeCondShort  = currentRange >= rangeFactor * prevRange
closeAbovePrevH = close > high[1]
closeBelowPrevL = close < low[1]
threePrevBear   = close[1] < open[1] and close[2] < open[2] and close[3] < open[3]
threePrevBull   = close[1] > open[1] and close[2] > open[2] and close[3] > open[3]
volCondLong     = volume >= volFactor * volume[1]
volCondShort    = volume >= volFactor * volume[1]

// Conditions for price relative to Keltner Channels
// avoid entering if price is above the upper band (overbought) on longs
// and avoid entering if price is below the lower band (oversold) on shorts
kcCondLong  = close <= upperKC
kcCondShort = close >= lowerKC

// === Entry Conditions ===
longCondition  = bullCandle and closeAbovePrevH and rangeCondLong and threePrevBear and volCondLong and kcCondLong
shortCondition = bearCandle and closeBelowPrevL and rangeCondShort and threePrevBull and volCondShort and kcCondShort

// === Stop‑loss and break‑even logic ===
// Persistent variables (using `var`) to store stop levels,
// profit targets and whether the stop has been moved to break‑even.
// We also record the entry price on each trade so that the break‑even
// calculation uses the true entry price instead of the current close.
var float long_stop        = na
var float short_stop       = na
var float targetLong       = na
var float targetShort      = na
var float longEntryPrice   = na
var float shortEntryPrice  = na
var bool  beLong           = false
var bool  beShort          = false

pip   = syminfo.mintick        // smallest price increment
slOff = 5 * pip                // stop‑loss offset: 5 pips
beOff = 2 * pip                // break‑even offset: 2 ticks

// === Long Entry ===
if (longCondition)
    // compute base low for stop placement
    float baseLow        = low < low[1] ? low : low[1]
    long_stop        := baseLow - slOff
    longEntryPrice   := close
    float risk       = longEntryPrice - long_stop
    targetLong       := longEntryPrice + risk  // 1:1 reward target
    beLong           := false
    strategy.entry("Long", strategy.long)
    strategy.exit("Long_SL", from_entry="Long", stop=long_stop)

// === Short Entry ===
if (shortCondition)
    float baseHigh       = high > high[1] ? high : high[1]
    short_stop        := baseHigh + slOff
    shortEntryPrice   := close
    float risk        = short_stop - shortEntryPrice
    targetShort       := shortEntryPrice - risk   // 1:1 reward target below entry
    beShort           := false
    strategy.entry("Short", strategy.short)
    strategy.exit("Short_SL", from_entry="Short", stop=short_stop)

// === Break‑even adjustment and dynamic stop update for long ===
if (strategy.position_size > 0)
    // Move stop to break‑even (entry price + 2 ticks) after hitting target
    if (not beLong and not na(targetLong) and high >= targetLong)
        long_stop := longEntryPrice + beOff
        beLong    := true
    // Exit on close of first bearish candle relative to previous candle
    bool exitLongCandle = close < open[1]
    if (exitLongCandle)
        strategy.close("Long", comment="Bearish reversal exit")
    // Update the stop dynamically if defined
    if (not na(long_stop))
        strategy.exit("Long_SL", from_entry="Long", stop=long_stop)

// === Break‑even adjustment and dynamic stop update for short ===
if (strategy.position_size < 0)
    // Move stop to break‑even (entry price − 2 ticks) after hitting target
    if (not beShort and not na(targetShort) and low <= targetShort)
        short_stop := shortEntryPrice - beOff
        beShort    := true
    // Exit on close of first bullish candle relative to previous candle
    bool exitShortCandle = close > open[1]
    if (exitShortCandle)
        strategy.close("Short", comment="Bullish reversal exit")
    // Update the stop dynamically if defined
    if (not na(short_stop))
        strategy.exit("Short_SL", from_entry="Short", stop=short_stop)

// === Plotting signals ===
plotshape(longCondition,  title="Long Signal",  location=location.belowbar, color=color.lime, style=shape.triangleup,   size=size.small, text="Long")
plotshape(shortCondition, title="Short Signal", location=location.abovebar, color=color.red,  style=shape.triangledown, size=size.small, text="Short")

// Plot Keltner Channels for reference
plot(midKC,   color=color.blue,   title="KC Middle")
plot(upperKC, color=color.orange, title="KC Upper")
plot(lowerKC, color=color.orange, title="KC Lower")

// End of script
